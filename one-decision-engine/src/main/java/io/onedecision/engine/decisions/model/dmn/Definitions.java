//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.10.30 at 01:30:38 PM GMT 
//


package io.onedecision.engine.decisions.model.dmn;

import io.onedecision.engine.decisions.api.DecisionConstants;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.validation.constraints.NotNull;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.namespace.QName;



/**
 * <p>
 * Java class for tDefinitions complex type.
 * 
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType name="tDefinitions"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{http://www.omg.org/spec/DMN/20151101/dmn.xsd}tNamedElement"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="import" type="{http://www.omg.org/spec/DMN/20151101/dmn.xsd}tImport" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="itemDefinition" type="{http://www.omg.org/spec/DMN/20151101/dmn.xsd}tItemDefinition" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{http://www.omg.org/spec/DMN/20151101/dmn.xsd}drgElement" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{http://www.omg.org/spec/DMN/20151101/dmn.xsd}artifact" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="elementCollection" type="{http://www.omg.org/spec/DMN/20151101/dmn.xsd}tElementCollection" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{http://www.omg.org/spec/DMN/20151101/dmn.xsd}businessContextElement" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute name="expressionLanguage" type="{http://www.w3.org/2001/XMLSchema}anyURI" default="http://www.omg.org/spec/FEEL/20140401" /&gt;
 *       &lt;attribute name="typeLanguage" type="{http://www.w3.org/2001/XMLSchema}anyURI" default="http://www.omg.org/spec/FEEL/20140401" /&gt;
 *       &lt;attribute name="namespace" use="required" type="{http://www.w3.org/2001/XMLSchema}anyURI" /&gt;
 *       &lt;attribute name="exporter" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *       &lt;attribute name="exporterVersion" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *       &lt;anyAttribute processContents='lax' namespace='##other'/&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "tDefinitions", propOrder = {
    "imports",
    "itemDefinitions",
    "drgElements",
    "artifacts",
    "elementCollection",
    "businessContextElements"
})
public class Definitions extends NamedElement implements Serializable {

    private static final long serialVersionUID = 891726198017969888L;

    @XmlElement(name = "import")
    protected List<Import> imports;
    protected List<ItemDefinition> itemDefinitions;
    @XmlElementRef(name = "drgElement", namespace = "http://www.omg.org/spec/DMN/20151101/dmn.xsd", type = JAXBElement.class, required = false)
    protected List<JAXBElement<? extends DrgElement>> drgElements;
    @XmlElementRef(name = "artifact", namespace = "http://www.omg.org/spec/DMN/20151101/dmn.xsd", type = JAXBElement.class, required = false)
    protected List<JAXBElement<? extends Artifact>> artifacts;
    protected List<ElementCollection> elementCollection;
    @XmlElementRef(name = "businessContextElement", namespace = "http://www.omg.org/spec/DMN/20151101/dmn.xsd", type = JAXBElement.class, required = false)
    protected List<JAXBElement<? extends BusinessContextElement>> businessContextElements;
    @XmlAttribute(name = "expressionLanguage")
    @XmlSchemaType(name = "anyURI")
    protected String expressionLanguage;
    @XmlAttribute(name = "typeLanguage")
    @XmlSchemaType(name = "anyURI")
    protected String typeLanguage;
    @XmlAttribute(name = "namespace", required = true)
    @XmlSchemaType(name = "anyURI")
    protected String namespace;
    @XmlAttribute(name = "exporter")
    protected String exporter;
    @XmlAttribute(name = "exporterVersion")
    protected String exporterVersion;

    /**
     * Gets the value of the imports property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the imports property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getImports().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Import }
     * 
     * 
     */
    public List<Import> getImports() {
        if (imports == null) {
            imports = new ArrayList<Import>();
        }
        return this.imports;
    }

    /**
     * Gets the value of the itemDefinitions property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the itemDefinitions property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getItemDefinitions().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ItemDefinition }
     * 
     * 
     */
    public List<ItemDefinition> getItemDefinitions() {
        if (itemDefinitions == null) {
            itemDefinitions = new ArrayList<ItemDefinition>();
        }
        return this.itemDefinitions;
    }

    /**
     * Gets the value of the drgElements property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the drgElements property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDrgElements().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link DrgElement }{@code >}
     * {@link JAXBElement }{@code <}{@link InputData }{@code >}
     * {@link JAXBElement }{@code <}{@link KnowledgeSource }{@code >}
     * {@link JAXBElement }{@code <}{@link BusinessKnowledgeModel }{@code >}
     * {@link JAXBElement }{@code <}{@link Decision }{@code >}
     * 
     * 
     */
    public List<JAXBElement<? extends DrgElement>> getDrgElements() {
        if (drgElements == null) {
            drgElements = new ArrayList<JAXBElement<? extends DrgElement>>();
        }
        return this.drgElements;
    }

    /**
     * @return Sub-set of <code>DrgElement</code>s that are
     *         <code>Decision</code>. Consequently, this is <em>NOT</em> a live
     *         list.
     */
    public Set<Decision> getDecisions() {
        HashSet<Decision> decisions = new HashSet<Decision>();
        for (JAXBElement<? extends DrgElement> el : getDrgElements()) {
            if (el.getValue() != null && el.getValue() instanceof Decision) {
                decisions.add((Decision) el.getValue());
            }
        }
        return decisions;
    }

    public Decision getDecision(@NotNull String decisionId) {
        for (JAXBElement<? extends DrgElement> el : getDrgElements()) {
            if (el.getValue() != null && el.getValue() instanceof Decision
                    && decisionId.equals(el.getValue().getId())) {
                return (Decision) el.getValue();
            }
        }
        return null;
    }
    
    public Set<BusinessKnowledgeModel> getBusinessKnowledgeModels() {
        HashSet<BusinessKnowledgeModel> bkms = new HashSet<BusinessKnowledgeModel>();
        for (JAXBElement<? extends DrgElement> el : getDrgElements()) {
            if (el.getValue() != null
                    && el.getValue() instanceof BusinessKnowledgeModel) {
                bkms.add((BusinessKnowledgeModel) el.getValue());
            }
        }
        return bkms;
    }

    /**
     * Gets the value of the artifacts property.
     * 
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the artifact property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * 
     * <pre>
     * getArtifacts().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link TextAnnotation }{@code >}
     * {@link JAXBElement }{@code <}{@link Association }{@code >}
     * {@link JAXBElement }{@code <}{@link Artifact }{@code >}
     * 
     * 
     */
    public List<JAXBElement<? extends Artifact>> getArtifacts() {
        if (artifacts == null) {
            artifacts = new ArrayList<JAXBElement<? extends Artifact>>();
        }
        return this.artifacts;
    }

    /**
     * Gets the value of the elementCollections property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the elementCollections property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getElementCollections().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ElementCollection }
     * 
     * 
     */
    public List<ElementCollection> getElementCollections() {
        if (elementCollection == null) {
            elementCollection = new ArrayList<ElementCollection>();
        }
        return this.elementCollection;
    }

    /**
     * Gets the value of the businessContextElements property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the businessContextElements property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getBusinessContextElements().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link BusinessContextElement }{@code >}
     * {@link JAXBElement }{@code <}{@link PerformanceIndicator }{@code >}
     * {@link JAXBElement }{@code <}{@link OrganizationUnit }{@code >}
     * 
     * 
     */
    public List<JAXBElement<? extends BusinessContextElement>> getBusinessContextElements() {
        if (businessContextElements == null) {
            businessContextElements = new ArrayList<JAXBElement<? extends BusinessContextElement>>();
        }
        return this.businessContextElements;
    }

    /**
     * Gets the value of the expressionLanguage property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getExpressionLanguage() {
        if (expressionLanguage == null) {
            return "http://www.omg.org/spec/FEEL/20140401";
        } else {
            return expressionLanguage;
        }
    }

    /**
     * Sets the value of the expressionLanguage property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setExpressionLanguage(String value) {
        this.expressionLanguage = value;
    }

    /**
     * Gets the value of the typeLanguage property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getTypeLanguage() {
        if (typeLanguage == null) {
            return "http://www.omg.org/spec/FEEL/20140401";
        } else {
            return typeLanguage;
        }
    }

    /**
     * Sets the value of the typeLanguage property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setTypeLanguage(String value) {
        this.typeLanguage = value;
    }

    /**
     * Gets the value of the namespace property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getNamespace() {
        return namespace;
    }

    /**
     * Sets the value of the namespace property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setNamespace(String value) {
        this.namespace = value;
    }

    /**
     * Gets the value of the exporter property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getExporter() {
        return exporter;
    }

    /**
     * Sets the value of the exporter property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setExporter(String value) {
        this.exporter = value;
    }

    /**
     * Gets the value of the exporterVersion property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getExporterVersion() {
        return exporterVersion;
    }

    /**
     * Sets the value of the exporterVersion property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setExporterVersion(String value) {
        this.exporterVersion = value;
    }

    public Definitions withImports(Import... values) {
        if (values!= null) {
            for (Import value: values) {
                getImports().add(value);
            }
        }
        return this;
    }

    public Definitions withImports(Collection<Import> values) {
        if (values!= null) {
            getImports().addAll(values);
        }
        return this;
    }

    public Definitions withItemDefinitions(ItemDefinition... values) {
        if (values!= null) {
            for (ItemDefinition value: values) {
                getItemDefinitions().add(value);
            }
        }
        return this;
    }

    public Definitions withItemDefinitions(Collection<ItemDefinition> values) {
        if (values!= null) {
            getItemDefinitions().addAll(values);
        }
        return this;
    }

    public Definitions withDrgElements(JAXBElement<? extends DrgElement> ... values) {
        if (values!= null) {
            for (JAXBElement<? extends DrgElement> value: values) {
                getDrgElements().add(value);
            }
        }
        return this;
    }

    public Definitions withDRGElements(Collection<JAXBElement<? extends DrgElement>> values) {
        if (values!= null) {
            getDrgElements().addAll(values);
        }
        return this;
    }
    
    @SuppressWarnings({ "rawtypes", "unchecked" })
    public void withDecisions(Decision... decisions) {
        for (Decision d : decisions) {
            withDrgElements(new JAXBElement(new QName(
                    DecisionConstants.DMN_URI, "decision"),
                    Decision.class, d));
        }
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
    public void withBusinessKnowledgeModels(BusinessKnowledgeModel... bkms) {
        for (BusinessKnowledgeModel bkm : bkms) {
            withDrgElements(new JAXBElement(new QName(
                    DecisionConstants.DMN_URI, "businessKnowledgeModel"),
                    BusinessKnowledgeModel.class, bkm));
        }
    }
    
    @SuppressWarnings({ "rawtypes", "unchecked" })
    public void withInputData(InputData... data) {
        for (InputData id : data) {
            withDrgElements(new JAXBElement(new QName(
                    DecisionConstants.DMN_URI, "inputData"),
                    InputData.class, id));
        }
    }
    
    @SuppressWarnings({ "rawtypes", "unchecked" })
    public void withKnowledgeSources(KnowledgeSource... sources) {
        for (KnowledgeSource ks : sources) {
            withDrgElements(new JAXBElement(new QName(
                    DecisionConstants.DMN_URI, "knowledgeSource"),
                    KnowledgeSource.class, ks));
        }
    }

    public Definitions withArtifact(JAXBElement<? extends Artifact> ... values) {
        if (values!= null) {
            for (JAXBElement<? extends Artifact> value: values) {
                getArtifacts().add(value);
            }
        }
        return this;
    }

    public Definitions withArtifact(Collection<JAXBElement<? extends Artifact>> values) {
        if (values!= null) {
            getArtifacts().addAll(values);
        }
        return this;
    }

    public Definitions withElementCollections(ElementCollection... values) {
        if (values!= null) {
            for (ElementCollection value: values) {
                getElementCollections().add(value);
            }
        }
        return this;
    }

    public Definitions withElementCollections(Collection<ElementCollection> values) {
        if (values!= null) {
            getElementCollections().addAll(values);
        }
        return this;
    }

    public Definitions withBusinessContextElements(Collection<JAXBElement<? extends BusinessContextElement>> values) {
        if (values!= null) {
            getBusinessContextElements().addAll(values);
        }
        return this;
    }

    public Definitions withExpressionLanguage(String value) {
        setExpressionLanguage(value);
        return this;
    }

    public Definitions withTypeLanguage(String value) {
        setTypeLanguage(value);
        return this;
    }

    public Definitions withNamespace(String value) {
        setNamespace(value);
        return this;
    }

    public Definitions withExporter(String value) {
        setExporter(value);
        return this;
    }

    public Definitions withExporterVersion(String value) {
        setExporterVersion(value);
        return this;
    }

    @Override
    public Definitions withName(String value) {
        setName(value);
        return this;
    }

    @Override
    public Definitions withDescription(String value) {
        setDescription(value);
        return this;
    }

    @Override
    public Definitions withExtensionElements(io.onedecision.engine.decisions.model.dmn.DmnElement.ExtensionElements value) {
        setExtensionElements(value);
        return this;
    }

    @Override
    public Definitions withId(String value) {
        setId(value);
        return this;
    }

    @Override
    public Definitions withLabel(String value) {
        setLabel(value);
        return this;
    }

}
